# Rol: Build Engine (Determinista)

## 1. Nombre

**Build Engine (Determinista)** — `build-engine`

## 2. Misión

Motor de optimización combinatoria de armadura puro y determinista — sin LLM. Recibe piezas de armadura y stat targets, devuelve los mejores builds posibles aplicando reglas, scoring y branch-and-bound.

## 3. Alcance

### Incluye

- Algoritmo de optimización combinatoria (`src/lib/builds/engine.ts`)
- Sistema de scoring de builds (stat tiers, distribución)
- Reglas de negocio: restricciones de exóticos, masterwork assumptions, mod slots
- Servicio de builds (`src/lib/builds/service.ts`)
- Route Handler `/api/builds/optimize`
- Tests unitarios del motor (`__tests__/lib/builds/engine.test.ts`)
- Performance: < 5s para inventarios típicos

### Excluye

- Interpretación de lenguaje natural (→ AI Advisor)
- Re-ranking por IA (→ AI Advisor)
- Explicaciones textuales de builds (→ AI Advisor)
- Descarga de inventario del jugador (→ Backend)
- UI de configuración de builds (→ Frontend)

## 4. Entradas requeridas

| Artefacto | Fuente |
|-----------|--------|
| API de inventario funcional (`/api/inventory`) | Backend |
| Tipos de items y stats del Manifest | Manifest & Data Modeling |
| Especificación de stat targets y presets | Producto |
| Variables de entorno configuradas | Arquitectura |

## 5. Salidas obligatorias

| Artefacto | Destino |
|-----------|---------|
| `src/lib/builds/engine.ts` estable y testeado | AI Advisor, Frontend |
| `src/lib/builds/service.ts` | API route |
| `src/app/api/builds/optimize/route.ts` | Frontend |
| Spec de formato I/O del endpoint | Frontend, AI Advisor, Testing |
| `__tests__/lib/builds/engine.test.ts` | Testing |
| `docs/handoffs/build-engine_<yyyymmdd-hhmm>.md` | Orquestador |

## 6. Ownership

```
src/lib/builds/engine.ts
src/lib/builds/service.ts
src/app/api/builds/optimize/route.ts
__tests__/lib/builds/engine.test.ts
```

## 7. Interfaces

### Produce

| Interfaz | Tipo | Consumida por |
|----------|------|---------------|
| `POST /api/builds/optimize` | REST JSON | Frontend, AI Advisor |
| `optimizeArmor(items, config)` | TS function | AI Advisor (server-side) |
| `BuildResult`, `BuildConfig` | TS types | Frontend, AI Advisor, Testing |

### Consume

| Interfaz | Tipo | Producida por |
|----------|------|---------------|
| Inventario del jugador (armadura) | TS types / API | Backend |
| `StatDefinition`, `ItemDefinition` | TS types | Manifest |
| Session service | TS module | Backend |

### Formatos I/O clave

```typescript
// POST /api/builds/optimize — Request
interface BuildOptimizeRequest {
  classType: 0 | 1 | 2;                          // Titan, Hunter, Warlock
  statPriority: [number, number, number, number, number, number]; // MOB, RES, REC, DIS, INT, STR
  assumeMasterwork: boolean;
  maxResults?: number;                             // default 5
}

// Response 200
interface BuildOptimizeResponse {
  results: BuildResult[];
  searchedItems: number;
  timing: number;                                  // ms
}

// BuildResult
interface BuildResult {
  items: ArmorPiece[];                             // 5 piezas
  totalTiers: number;
  stats: [number, number, number, number, number, number];
  score: number;
}
```

## 8. Guardrails

- ❌ **NO** usar LLM ni IA para calcular stats — este motor es determinista
- ❌ **NO** mutar el inventario del jugador (solo lectura)
- ❌ **NO** devolver más de `maxResults` builds para evitar payloads enormes
- ⚠️ Optimización debe completarse en < 5s para ~100 piezas
- ⚠️ Manejar edge cases: sin armadura, < 5 piezas, solo exóticos
- ⚠️ Máximo 1 pieza exótica por build (regla de D2)
- ⚠️ Branch-and-bound para podar ramas inviables temprano
- ⚠️ Tests unitarios obligatorios para el motor

## 9. Definition of Done

- [ ] `/api/builds/optimize` devuelve builds válidos para Titan, Hunter, Warlock
- [ ] Respeta restricción de 1 exótico por build
- [ ] Scoring correcto: suma de stat tiers
- [ ] Optimización completa en < 5s para inventarios típicos
- [ ] Edge cases manejados: sin armadura, inventario parcial
- [ ] Tests unitarios del engine pasan al 100%
- [ ] Tipos exportados: `BuildResult`, `BuildConfig`, `ArmorPiece`
- [ ] `npm run build` sin errores
- [ ] Handoff generado en `docs/handoffs/`

## 10. Formato de handoff

> Archivo: `docs/handoffs/build-engine_<yyyymmdd-hhmm>.md`

### Resumen

Estado del motor de builds: algoritmo, performance, cobertura de tests.

### Cambios

```
- src/lib/builds/engine.ts (nuevo/modificado)
- src/app/api/builds/optimize/route.ts (nuevo)
- __tests__/lib/builds/engine.test.ts (nuevo)
```

### Cómo probar

```bash
npm run dev
# Test unitarios:
npm test -- __tests__/lib/builds/engine.test.ts
# Test manual:
curl -X POST https://localhost:3000/api/builds/optimize \
  -H 'Content-Type: application/json' \
  -d '{"classType":0,"statPriority":[0,100,100,0,0,0],"assumeMasterwork":true}'
```

### Decisiones tomadas

- Ej: "Branch-and-bound elegido sobre fuerza bruta para escalar a >200 piezas"

### Riesgos / limitaciones

- Ej: "No considera mods de armadura en el scoring actual"

### TODOs para el siguiente rol

- Ej: "AI Advisor puede llamar a `optimizeArmor()` directamente para re-rankear"
- Ej: "Frontend debe mapear los `BuildResult` a componentes visuales"
